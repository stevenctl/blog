{"/icons/":{"data":{"":" academic-cap\nadjustments\nannotation\narchive\narrow-circle-down\narrow-circle-left\narrow-circle-right\narrow-circle-up\narrow-down\narrow-left\narrow-narrow-down\narrow-narrow-left\narrow-narrow-right\narrow-narrow-up\narrow-right\narrow-sm-down\narrow-sm-left\narrow-sm-right\narrow-sm-up\narrow-up\narrows-expand\nat-symbol\nbackspace\nbadge-check\nban\nbeaker\nbell\nbook-open\nbookmark\nbookmark-alt\nbriefcase\ncake\ncalculator\ncalendar\ncamera\ncash\nchart-bar\nchart-pie\nchart-square-bar\nchat\nchat-alt\nchat-alt-2\ncheck\ncheck-circle\nchevron-double-down\nchevron-double-left\nchevron-double-right\nchevron-double-up\nchevron-down\nchevron-left\nchevron-right\nchevron-up\nchip\nclipboard\nclipboard-check\nclipboard-copy\nclipboard-list\nclock\ncloud\ncloud-download\ncloud-upload\ncode\ncog\ncollection\ncolor-swatch\ncredit-card\ncube\ncube-transparent\ncurrency-bangladeshi\ncurrency-dollar\ncurrency-euro\ncurrency-pound\ncurrency-rupee\ncurrency-yen\ncursor-click\ndatabase\ndesktop-computer\ndevice-mobile\ndevice-tablet\ndocument\ndocument-add\ndocument-download\ndocument-duplicate\ndocument-remove\ndocument-report\ndocument-search\ndocument-text\ndots-circle-horizontal\ndots-horizontal\ndots-vertical\ndownload\nduplicate\nemoji-happy\nemoji-sad\nexclamation\nexclamation-circle\nexternal-link\neye\neye-off\nfast-forward\nfilm\nfilter\nfinger-print\nfire\nflag\nfolder\nfolder-add\nfolder-download\nfolder-open\nfolder-remove\ngift\nglobe\nglobe-alt\nhand\nhashtag\nheart\nhome\nidentification\ninbox\ninbox-in\ninformation-circle\nkey\nlibrary\nlight-bulb\nlightning-bolt\nlink\nlocation-marker\nlock-closed\nlock-open\nlogin\nlogout\nmail\nmail-open\nmap\nmenu\nmenu-alt-1\nmenu-alt-2\nmenu-alt-3\nmenu-alt-4\nmicrophone\nminus\nminus-circle\nminus-sm\nmoon\nmusic-note\nnewspaper\noffice-building\npaper-airplane\npaper-clip\npause\npencil\npencil-alt\nphone\nphone-incoming\nphone-missed-call\nphone-outgoing\nphotograph\nplay\nplus\nplus-circle\nplus-sm\npresentation-chart-bar\npresentation-chart-line\nprinter\npuzzle\nqrcode\nquestion-mark-circle\nreceipt-refund\nreceipt-tax\nrefresh\nreply\nrewind\nrss\nsave\nsave-as\nscale\nscissors\nsearch\nsearch-circle\nselector\nserver\nshare\nshield-check\nshield-exclamation\nshopping-bag\nshopping-cart\nsort-ascending\nsort-descending\nsparkles\nspeakerphone\nstar\nstatus-offline\nstatus-online\nstop\nsun\nsupport\nswitch-horizontal\nswitch-vertical\ntable\ntag\ntemplate\nterminal\nthumb-down\nthumb-up\nticket\ntranslate\ntrash\ntrending-down\ntrending-up\ntruck\nupload\nuser\nuser-add\nuser-circle\nuser-group\nuser-remove\nusers\nvariable\nvideo-camera\nview-boards\nview-grid\nview-grid-add\nview-list\nvolume-off\nvolume-up\nwifi\nx\nx-circle\nzoom-in\nzoom-out\n"},"title":"Icons"},"/posts/":{"data":{"":" Art Wave Function Collapse "},"title":"Topics"},"/posts/art/":{"data":{"":"I don\u0026rsquo;t consider myself much of an artist. To learn 3D, I could either download other people\u0026rsquo;s assets or make my own. It turns out you get a much better feel for how all this stuff works by just making things in a DCC. I found Blender For Dummies for $10 at a used bookstore. It turned out to do a good job of explaining how Blender is structured and not just How to Make Stuff.\nTrain Station Characters and Animation "},"title":"Art"},"/posts/art/characters/":{"data":{"":"","cat-knight#Cat Knight":"\nI haven\u0026rsquo;t spent a ton of time character modeling. This is what I\u0026rsquo;ve been able to make so far.\nLegfish This was the first character I made. Inspired by a figurine I sort of made with my wife\u0026rsquo;s leftover clay.\nFor this I used a Skin Modifier and Subdivision Surface based workflow. Joey Carlino has some great tutorials on YouTube.\nThe major advantage is there is almost no real geometry to manage until you apply the modifier. This delays the need to think about topology. This was one of the first things I did when learning blender. I couldn\u0026rsquo;t really make sense of when branches would merge and I ended up avoiding this workflow so I would have 100% control of the topology. In the future, I want to revisit this approach now that I understand topology and modeling better. It\u0026rsquo;s easier now for me to fixup things that aren\u0026rsquo;t perfect just using the modifiers.\nCat Knight This is my first run/walk cycle! I\u0026rsquo;m pretty proud of it. At first I was resigned to using Mixamo because animation is too hard. It was difficult to get good results with my stylized characters massive heads. The animations were too \u0026ldquo;real\u0026rdquo; as well. The character is cartoony and the motion should be too.\nI read the first few chapters of The Animator\u0026rsquo;s Survival Kit and while I don\u0026rsquo;t plan on becoming a serious animator, the basic concepts are enough to help me work quicker and make something passable.\nThis was box modeled for the most part. To make things smoother I would use a\nCatmull-Clark Subdivision and then use the Un-Subdivide operator to keep the amount of geometry manageable while still getting a bit more smoothness/roundness in the mesh. I got to try out some topology tricks at the knees and elbows to help them deform properly.\nTo make the helmet, I just copied the head and cut out some parts. Same with the boots. The armor was lifted from the Synty Fantasy Hero asset pack. I just scaled things around until it fit.I don\u0026rsquo;t plan on keeping it long term but it looks good enough for now.\n","gobgob#Gobgob":"\nBecause I already had a stylized biped base all rigged, I reused that and just modeled a new head and stitched that on. I learned a bit about how to reroute edge/face flow after extruding the ears. I like him a lot.\n","legfish#Legfish":""},"title":"Characters and Animation"},"/posts/art/train/":{"data":{"":"","#":"I saw this picture on Reddit or something and I decided to (sorta) recreate it. There were other decorations I wanted to put in the train station like a Goblin themed vending machine, and better looking torches. I needed to wrap it up and move on though.\nTo build the environment, I re-used my tileset that I made for my Wave Function Collapse based level editor. Rather than copying the tiles into this blender file and arranging them by hand I was able to use the level editor in godot, save the scene using PackedScene and then Godot let me export to GLTF, which I then imported in blender.\nThe major caveat is that even though may tiles are re-used, the export duplicated mesh data for each instance. I plan on looking into into whether this is something that can be optimized in Godot\u0026rsquo;s exporter or is a restriction in the GLTF format. The blend file should not be 90 megabytes.\nAnimation This was my first time doing a couple of things in Blender.\nKeying arbitrary properties. The torches have their \u0026ldquo;Power\u0026rdquo; animated to go up and down. The phase offset on the wave texture is also keyed to increase with time.\nUsing the Non-Linear Animation Tool. Before I would just duplicate the keyframes for the duration of the clip. I wanted to repeat the idle animation of my character.\nProjection I personally liked using an orthographic camera for rendering as an art piece.\nPerspective projection gives much more of an \u0026ldquo;in-game\u0026rdquo; feel. It would be cool to make put this in a game someday. Maybe as a fast travel system like Hollow Knight\u0026rsquo;s stag.\nWireframes One lesson in this project is that it\u0026rsquo;s not always worth it to cut holes in things that will never deform and you can cover using separate objects. It was also the first time I\u0026rsquo;d really used the bevel modifier and needed to keep the topology clean enough for smooth shading.\nAlthough not strictly necessary, I did take the time to model the interior of the train.\nTexturing To color, I used a simple pallete texture. Entire faces are each assigned a color using this texture. Except for the \u0026ldquo;LCD\u0026rdquo; screen on the front of the train. Although this is based on a Japanese subway train, I don\u0026rsquo;t know Japanese. I know a tiny bit of Mandarin, but I don\u0026rsquo;t really know how to write it. If I understand correctly, a lot of characters are used in Japan as well. Anyway, my wife and I thought it would be funny if it said the destination was \u0026ldquo;Train Station\u0026rdquo;.\nI wanted only the text on the screen to be emissive. It probably isn\u0026rsquo;t the simplest solution, but the first thing I thought of is to check for certain colors and plug that into the \u0026ldquo;emsisive\u0026rdquo; socket of Blender\u0026rsquo;s BSDF node. I ended up also using that for the lights on the interior.\nI didn\u0026rsquo;t feel like modeling anything else, so for the underneath of the train we\u0026rsquo;re just gonna say \u0026ldquo;it\u0026rsquo;s magic\u0026rdquo;. I decided to mess around with some built-in noise textures and the Wave Texture node is pretty cool. I made parts of it transparent and most of it emissive and it looked deceint. Plugging it into the volume output looked decent in the render so I left it.\nThe walls use some PBR textures I bought from CGTrader (well worth it imo). I\u0026rsquo;ll probably talk about it later, but I can\u0026rsquo;t/don\u0026rsquo;t want to unwrap these tiles, so I use a triplanar mapping. I still can\u0026rsquo;t figure out a good way to make Blender ignore object rotations when using this. For the tiles visible in the render, I unroated the objects and rotated the geometry instead.\n"},"title":"Train Station"},"/posts/wfc/wfc-01-intro/":{"data":{"creating-a-tileset#Creating a tileset":"At some point in time I followed some indie devs on Twitter. I\u0026rsquo;d occasionally see retweets of a cute building game from Oskar Stålberg. Didn\u0026rsquo;t think too much of it at the time. Later I stumbled on Martin Donald\u0026rsquo;s Wave Function Collapse video. The idea was explained so well that I had to try it out.\nCreating a tilesetIn the talk Beyond Townscapers, and on twitter Oskar explains the concept of the dual-grid. Essentially: cut your tiles in the middle. This is my first time making a tileset of any kind, and I don\u0026rsquo;t know why anyone would do it any other way.\nI manually modeled out what I thought were the required set of tiles in blender. I used this graphic to guide me, and thought moving to 3 dimensions wouldn\u0026rsquo;t be that bad. I would just need to make each of those 2D tiles 3 times: once each for the top, middle and bottom layers if you\u0026rsquo;re slicing vertically.\n","determining-adjacency#Determining adjacency":"face_verts = [] for v in mesh.vertices: # round to 3 decimals so equality will (sometimes) work vert_coord_3d = rounded_coordinate(vert) # compare the dimension for this face\u0026#39;s axis location = vert_coord_3d[face.component] # using float equality is a terrible idea... if vert_location_1d == face_location_1d: face_verts.append(vert.co) socket_id = socket_hash(face_verts) Given a set of tiles, I could go through and look for all the vertices that sat on the bounding box faces and generate \u0026ldquo;sockets\u0026rdquo;. This would be my primary piece of adjacency data. If the sockets lined up, it was valid to place one tile adjacent to another.\n","implementing-wfc#Implementing WFC":"With a tileset, and basic adjacency information it wasn\u0026rsquo;t too hard to whip up a basic WFC generator. For a detailed tutorial, see Martin Donald\u0026rsquo;s video. The basic structure looks like this:\ndef solve(): work_list = [] solved = False iteration = 0 while not solved and iteration \u0026lt; MAX_ITERATIONS: collapsed = collapse() if collapsed: work_list.append(collapsed) else: solved = True while len(work_list) \u0026gt; 0: cell = work_list.pop() work_list += propagate(cell) def collapse(): unsolved = [cell for cell in grid if len(cell.possibilities) \u0026gt; 1] if len(unsolved) == 0: # Every cell is solved (or impossible...) return None # Find the unsolved cell with the fewest number of remaining possible tiles. cell = min(unsolved, key=lambda cell: len(cell.possibilities)) # Reduce it to one possibility cell.possibilities = [random.choice(cell.possibilities)] return # reduce the possibilities of neighboring cells # to only include tiles that have adjacency sockets that line up. # return the set of cells that were affected so we can recursively # propagate the constraint def propagate() -\u0026gt; List[Cell]: pass Using this in a Blender python script, I could generate a random set of tiles that \u0026ldquo;fit\u0026rdquo; together in some space:\n","making-it-interactive#Making it interactive":"Next, I added a preprocessing step to force empty tiles everywhere but specified coordinates. This is essentially voxel data. BorisTheBrave calls this \u0026ldquo;Driven\u0026rdquo; WFC.\n[ (1, 1, 1), (2, 1, 1), (3, 1, 1), (4, 1, 1), (5, 1, 1), (1, 2, 1), (2, 2, 1), (3, 2, 1), (4, 2, 1), (5, 2, 1), (1, 1, 2), (2, 1, 2), (3, 1, 2), (4, 1, 2), (5, 1, 2), (1, 2, 2), (2, 2, 2), (3, 2, 2), (4, 2, 2), (5, 2, 2), (1, 1, 4), (2, 1, 4), (3, 1, 4), (4, 1, 4), (5, 1, 4), (1, 1, 4), (2, 1, 4), (3, 1, 4), (4, 1, 4), (5, 1, 4), ] Now I can build something blocky like in Minecraft. By typing coordinates by hand in python! Great\u0026hellip;\n","there-are-some-major-issues#There are some major issues":"Someone more seasoned in procedural generation, or 3D graphics in general may have noticed a few issues. I\u0026rsquo;ll highlight the major 3 that will each get a dedicated follow up.\n1. Some tiles have flipped normals\nNotice the red tiles on the corners of the last image?\nThe main issue is that the sockets don\u0026rsquo;t contain any information about which side is on the \u0026ldquo;inside\u0026rdquo; or outside. There are a few ways to go about tackling this.\n2. Sockets rely float equality and perfect meshes\nWhile we want two adjacent tiles to fit perfectly, sometimes they don\u0026rsquo;t need to. Mesh skirts and clever artwork can be used to cover up seams. If we rely on 3 decimal places of accuracy on every vertex, we will have a hard time creating new tiles and pull our hair out when tiles that should fit together have different sockets.\n3. The tileset is incomplete\nAt this phase in the project, I would create some tiles, then create somee voxel data and see if the generator would fail. When the generator failed, I\u0026rsquo;d stare for a while until I realized I missed some 3D version of Oskar\u0026rsquo;s dual grid guide. In the screenshots above, we\u0026rsquo;re missing every variation of the \u0026ldquo;diagonal\u0026rdquo; tile.\n"},"title":"Wave Function Collapse: First attempt"},"/posts/wfc/wfc-02-tiles/":{"data":{"256-tiles-is-a-lot#256 tiles is a lot":"In the article, Oskar points out that a lot of these end up being rotations or flipped versions of other permutations. He reduced that to 67 unique cases. I ended up with 53.. I\u0026rsquo;m still curious how we got different results.\nI\u0026rsquo;m not much of an artist. 53 was still too many for me!\nIn my initial attempt, I got pretty far by manually enumerating all the possibilities needed for an infinite grid. Surely I could manually come up with everything needed for a 2x2x2 grid.\nI was able to go back to this classic image:\nTo give these names:\nEmpty Corner Edge Diagonal Bend Full If we only model the dual grid of those we can eliminate the need to make a \u0026ldquo;diagonal\u0026rdquo;. And we don\u0026rsquo;t have to model an \u0026ldquo;empty\u0026rdquo; tile. So I started with these 4 tiles:\nTo expand this to 3D, we transitions that let us go upwards. We can simply rotate these 4 tiles and voila. We\u0026rsquo;re at 8 tiles.\nIt doesn\u0026rsquo;t fully cover it though. We have to be able to transition vertically between flat tiles or edge tiles. We\u0026rsquo;ll call these \u0026ldquo;lip\u0026rdquo; tiles since they\u0026rsquo;re kind of skinny. There are 5. 4 for to match up to the base cases and a 5th that is a corner between two lips. It\u0026rsquo;s basically the \u0026ldquo;outward\u0026rdquo; part of an \u0026ldquo;outward blob cut\u0026rdquo; approach.\nFinally, we duplicate all of these and flip them upside down so we have some dedicated for the top layer of our 2x2x2 grid.\nIn total There are 26 tiles. Very manageable!\n","brute-forcing-it-by-hand#Brute Forcing it by hand":"Oskar Stålberg\u0026rsquo;s and BorisTheBrave\u0026rsquo;s willingness to share the dirty details of their hard work is invaluable.\nBrute Forcing it by handIn the last blog, I showed a tileset created entirely by hand. Some very important tiles were missing. These diagnonal pieces:\nWhen I realized I needed these, I added more test cases and things still broke. I later realized, that I also needed these combinations of corners and edges:\nThere must be an algorighmic way.\n","orienting-the-tiles#Orienting the tiles":"Simply selecting the correct tile type is not enough. We must rotate the tiles so that they line up properly. While there are probably some rules we could add to the mostrosity above, we don\u0026rsquo;t need to. Doing so would not only add complexity to the code, but require some manual setup in Blender.\nInstead we can cheese it with Wave Function Collapse! Using a tileset with very simple geometry, we can generate all the sockets for these \u0026ldquo;base\u0026rdquo; tiles. These only ever need to be generated once, and we can store them in some JSON file to avoid needing our geometry to be perfect in the future.\nOnce we have this \u0026ldquo;golden\u0026rdquo; adjacency information file, we can use WFC to align everything correctly.\n","oskar-already-figured-it-out#Oskar already figured it out":"It turns out before Townscaper he made a smaller version called Brick Block. In an article in Vertex magazine he explains a way to cut a cube into 8 octants. It turns out that if you look at all the possibilities of having an octant filled or not is 2 to the power of 8 (256).\nLooking at this like an 8 bit integer means we have \u0026ldquo;cube IDs\u0026rdquo; from 0 to 255. If you have all these tiles, you will never have an unsolvable grid of voxel data.\n","result#Result":"\nAt this point, we can make the geometry as complex as we want. But if the geometry is complex, how can we get nice sockets for the actual WFC using these generated tiles? The next post will explain a better system for adjacency that doesn\u0026rsquo;t rely on analzying 3D meshes.\n","turning-them-into-dual-tiles#Turning them into dual tiles":"Now to combine these tiles.\nWe can write an autotiler based on the which octants are filled. To store the classification data we use a special naming scheme that includes:\nTheir base type - Lip, Corner, Bend, Edge Their Layer - Top, Bottom Their Direction - Horizontal, Vertical, Horizontal + Vertical, Corner Note: The following code was written during a long layover after an 18 hour flight. At some point I\u0026rsquo;ll go back and clean it up. In the meantime, I hope the comments are accurate.\ndef base_tile_for(octant, cube_id): cube_arr = int_to_cube(cube_id) prefix = [\u0026#34;Bottom\u0026#34;, \u0026#34;Top\u0026#34;][int(octant[2])] # west, east, south, north, bottom, top adjacency = [] for axis in [0, 1, 2]: # check directly adjacent (this axis changes) for delta in [-1, 1]: delta_vec = np.array([0, 0, 0]) delta_vec[axis] = delta cc = octant + delta_vec adjacency.append(cube_cell_filled(cube_arr, cc)) adj_axes = sum(1 for v in [xx, yy, zz] if v) # if there was any vertical adjacency, use .V suffix z_adj = any(adjacency[4:]) # check how many cells are filled in this octant\u0026#39;s plane for each axis n_in_axis = [ cube_arr[octant[0], :, :].sum(), cube_arr[:, octant[1], :].sum(), cube_arr[:, :, octant[2]].sum(), ] # if all 4 cells in some plane were filled, there was a \u0026#34;wall\u0026#34; in that axis # walls result in needing a \u0026#34;lip\u0026#34; walls = [n == 4 for n in n_in_axes] if any(walls): hw, vw = walls[0] or walls[1], walls[2] if hw and vw: suffix = \u0026#34;Lip\u0026#34; if adj_axes == 3: suffix += \u0026#34;.C\u0026#34; elif walls[0] and walls[1]: suffix = \u0026#34;Lip.V\u0026#34; else: if adj_axes == 2: suffix = \u0026#34;Flat\u0026#34; if vw else \u0026#34;Wall\u0026#34; else: suffix = \u0026#34;Lip.Bend\u0026#34; if vw else \u0026#34;Lip.Bend.V\u0026#34; elif adj_axes == 0: suffix = \u0026#34;Corner\u0026#34; elif adj_axes == 1: suffix = \u0026#34;Edge\u0026#34; suffix += \u0026#34;.V\u0026#34; if z_adj else \u0026#34;.H\u0026#34; elif adj_axes == 2: suffix = \u0026#34;Bend\u0026#34; suffix += \u0026#34;.V\u0026#34; if z_adj else \u0026#34;.H\u0026#34; elif adj_axes == 3: suffix = \u0026#34;Bend.HV\u0026#34; else: raise Exception(\u0026#34;Somehow adjacency count isn\u0026#39;t covered..??\u0026#34;) return prefix + \u0026#34;.\u0026#34; + suffix "},"title":"Wave Function Collapse: Enumerating tiles"},"/posts/wfc/wfc-03-sockets/":{"data":{"building-adjacency-map#Building Adjacency Map":"So far we\u0026rsquo;ve looked at optimizing the asset creation workflow, and dug into some details on how we get that into the game. What will we do with that data in game?\nclass Adjacency: # Index first by face, then by prototype id. # The value is a bitmask. matrix = [[], [], [], [], [], []] def __init__(prototypes: List[Prototype]): for face in range(6): for i in range(len(prototypes)): for j in range(len(prototypes)): if prototypes[i].compatible(face, prototypes[j]): matrix[face][i] \u0026amp;= (1 \u0026lt;\u0026lt; j - 1) matrix[opposite(face), to] \u0026amp;= (1 \u0026lt;\u0026lt; j - 1) Here we build a list of 6 arrays of N bitmasks, where the bitmask has length N.\nIf we look at this nice WFC web demo, we can think of each cell in our grid as containing the entire tilset to start. The tiles available to choose in each cell can be called its domain.\nOnce a cell \u0026ldquo;picks\u0026rdquo; a tile, we set its domain to a single item. Neightbors domains are reduced to only contain tiles compatible with something in it\u0026rsquo;s neighbors domain.\nOur adjacency could be modeled as a list of 6 faces where each element in the list maps a socket to the set of prototypes that are compatible with it.\nA naive way to propagte things out would be something like this using a ton of unions:\nallowed = [] for possibility in self.domain: allowed = allowed.union(adjacency[face][possibility]) domain = domain.intersection(allowed) Instead we could have those sets be a BigBitmask. Essentially a list of integers. 4 64 bit integers would be 256 possible tiles. Each bit index represents a tile ID. Replace the union with a bitwise OR and things speed up quite a bit.\nThe caveat is iterating over the \u0026ldquo;set bits\u0026rdquo; could be slow, but most CPUs support an instruction for finding the \u0026ldquo;next set bit\u0026rdquo;.\nallowed = [] for possibility in set_bit_indices(self.domain): allowed |= adjacency[face][possibility] domain \u0026amp;= allowd ","defining-sockets-and-compatibility#Defining Sockets and Compatibility":"In the previous post, we discussed how we could use 8 bit integers to represent a cube divided into 8 octants. This idea inspired me to abandon mesh data as a means for adjacency data in favor of 2D images.\nDefining Sockets and CompatibilityPreviously, sockets were opaque identifiers assigned to each face of a tile. Instead, let\u0026rsquo;s make them images.\nThose images are a low resolution representation of the actual tile.\nWhen comparing horizontal sockets, they\u0026rsquo;re compatible only if they mirror images of each other. That is the north socket of tile A needs to be the mirror of the south socket of tile B for them to connect.\nFor vertical sockets, we expect sockets to be identical. The top of one being identical to the bottom of another will be compatible.\n","dense-representation#Dense representation":"So far we haven\u0026rsquo;t talked about the format we store any of our tileset data in.\nEach tile gets 4 or 8 variants. Each is called a prototype. It has roughly this format:\n{ \u0026#34;mesh\u0026#34;: \u0026#34;gen_1\u0026#34;, // reference to the mesh we would render \u0026#34;rotation\u0026#34;: 0, // the number of 90 degree rotations to use when rendering \u0026#34;flip\u0026#34;: false, // whether to flip the mesh on the x axis when rendering // the \u0026#34;sockets\u0026#34; on each face \u0026#34;north\u0026#34;: \u0026#34;???\u0026#34;, \u0026#34;east\u0026#34;: \u0026#34;???\u0026#34;, \u0026#34;south\u0026#34;: \u0026#34;???\u0026#34;, \u0026#34;west\u0026#34;: \u0026#34;???\u0026#34;, \u0026#34;top\u0026#34;: \u0026#34;???\u0026#34;, \u0026#34;bottom\u0026#34;: \u0026#34;???\u0026#34; } If sockets are images, how will we store them in a JSON file? Base64 encode them, then decode them to our game engine\u0026rsquo;s native Image struct or object? What is an image if not a list of which pixels are and aren\u0026rsquo;t filled. If we have only 1 color in our image, and it\u0026rsquo;s 7x7 pixels we only need 49 bits. This fits easily in a 64 bit uint. The following socket has the first 3 bits set 0b11100000 (7 in decimal).\nUsing some leftover bits, we can store information like whether the image is the flipped version of another image. Now when we compare a horizontal socket, we don\u0026rsquo;t need to loop over the image and actually flip it. We can simply figure out the unique set of images in our tileset before hand, and mark some as flipped. The check becomes a == b ^ (1 \u0026lt;\u0026lt; 63). We might use another bit to store whether the image is symmetrical so we know NOT to flip the bit.\nThis gives us:\nA dense way to store sockets in JSON. A ~quick way to compare them at runtime. This doesn\u0026rsquo;t matter much. ","flexibility-in-geometry#Flexibility in geometry":"\nWe don\u0026rsquo;t have to worry about floating point errors or perfectly aligning geometry. If we want to cover seams with some rocks or a mesh skirt, we are free to do so.\n","generating-images#Generating Images":"In the previous post we generated our tiles by enumerating filled octants. If we take the 4 octants that make up one face, we can convert that into a 7x7 image easily. Let\u0026rsquo;s say if two adjacent octants are filled, we want the whole row of pixels to be filled. If we have 3 of 4 octants the socket will look like this:\nThe code is relatively straightforward:\ndef gen_sock(cube_id: int, face_name: str, seen_socks: Sockets, bitmap_size=7) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34; Convert a 2x2 face into a bitmap, then encode it as a socket. \u0026#34;\u0026#34;\u0026#34; cube = int_to_cube(cube_id) face = get_face(cube, face_name) # Generate a bitmap that has some room in the middle. # It\u0026#39;s 7x7, so we can have more complex tiles with complex sockets elsewhere. assert bitmap_size % 2 == 1 # must be odd for 1 pixel gutter in center fill_size = int(bitmap_size / 2) socket_bitmap = np.zeros((7, 7), dtype=int) for x in range(len(face)): for y in range(len(face[x])): if face[x, y] == 0: continue sx = x * (bitmap_size - fill_size) sy = y * (bitmap_size - fill_size) ex = sx + fill_size ey = sy + fill_size if x == 0 and face[x + 1, y] == 1: ex += 1 if y == 0 and face[x, y + 1] == 1: ey += 1 socket_bitmap[sx:ex, sy:ey] = 1 # Set the very center bit when the whole thing is filled socket_bitmap[fill_size, fill_size] = (face == 1).all() # Deduplicate sockets that are just transforms of other sockets if not seen_socks: raise AssertionError(\u0026#34;seen socks util is required\u0026#34;) if face_name in v_face_names: return seen_socks.store_v(socket_bitmap) return seen_socks.store_h(socket_bitmap) "},"title":"Wave Function Collapse: Adjacency data"}}