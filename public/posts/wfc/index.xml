<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wave Function Collapse of Dirt is Food</title>
    <link>https://landow.dev/posts/wfc/</link>
    <description>Recent content in Wave Function Collapse on Dirt is Food</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 26 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://landow.dev/posts/wfc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Wave Function Collapse: Adjacency data</title>
      <link>https://landow.dev/posts/wfc/wfc-03-sockets/</link>
      <pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://landow.dev/posts/wfc/wfc-03-sockets/</guid>
      <description>In the previous post, we discussed how we could use 8 bit integers to represent a cube divided into 8 octants. This idea inspired me to abandon mesh data as a means for adjacency data in favor of 2D images.
Defining Sockets and CompatibilityPreviously, sockets were opaque identifiers assigned to each face of a tile. Instead, let&amp;rsquo;s make them images.
Those images are a low resolution representation of the actual tile.</description>
      <content:encoded><![CDATA[<p>In the previous post, we discussed how we could use 8 bit integers to represent
a cube divided into 8 octants. This idea inspired me to abandon mesh data as
a means for adjacency data in favor of 2D images.</p>
<h1>Defining Sockets and Compatibility</h1><p>Previously, sockets were opaque identifiers assigned to each face of a tile.
Instead, let&rsquo;s make them images.</p>
<p><img src="socks.png" alt="basic sockets" loading="lazy" /></p>
<p>Those images are a low resolution representation of the actual tile.</p>
<p><img src="sock_arch.png" alt="socket with mesh" loading="lazy" /></p>
<p>When comparing horizontal sockets, they&rsquo;re compatible only if they mirror images of each other. That is the north socket of tile A
needs to be the mirror of the south socket of tile B for them to connect.</p>
<p>For vertical sockets, we expect sockets to be identical. The top of one being identical to the bottom of another will be compatible.</p>
<h1>Dense representation</h1><p>So far we haven&rsquo;t talked about the format we store any of our tileset data in.</p>
<p>Each tile gets 4 or 8 variants. Each is called a prototype. It has roughly this format:</p>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-0"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;mesh&#34;</span><span class="p">:</span> <span class="s2">&#34;gen_1&#34;</span><span class="p">,</span> <span class="c1">// reference to the mesh we would render
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nt">&#34;rotation&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// the number of 90 degree rotations to use when rendering
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nt">&#34;flip&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// whether to flip the mesh on the x axis when rendering
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the &#34;sockets&#34; on each face
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nt">&#34;north&#34;</span><span class="p">:</span> <span class="s2">&#34;???&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;east&#34;</span><span class="p">:</span> <span class="s2">&#34;???&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;south&#34;</span><span class="p">:</span> <span class="s2">&#34;???&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;west&#34;</span><span class="p">:</span> <span class="s2">&#34;???&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;top&#34;</span><span class="p">:</span> <span class="s2">&#34;???&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;bottom&#34;</span><span class="p">:</span> <span class="s2">&#34;???&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-0">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<p>If sockets are images, how will we store them in a JSON file? Base64 encode them, then decode them
to our game engine&rsquo;s native Image struct or object? What is an image if not a list of which pixels
are and aren&rsquo;t filled. If we have only 1 color in our image, and it&rsquo;s 7x7 pixels we only need 49 bits.
This fits easily in a 64 bit <code>uint</code>. The following socket has the first 3 bits set <code>0b11100000</code> (7 in decimal).</p>
<p><img src="sock7.png" alt="socket 7" loading="lazy" /></p>
<p>Using some leftover bits, we can store information like whether the image is the flipped version of another
image. Now when we compare a horizontal socket, we don&rsquo;t need to loop over the image and actually flip it.
We can simply figure out the unique set of images in our tileset before hand, and mark some as flipped.
The check becomes <code>a == b ^ (1 &lt;&lt; 63)</code>. We might use another bit to store whether the image is symmetrical
so we know NOT to flip the bit.</p>
<p>This gives us:</p>
<ul>
<li>A dense way to store sockets in JSON.</li>
<li>A ~quick way to compare them at runtime. This doesn&rsquo;t matter much.</li>
</ul>
<h1>Generating Images</h1><p>In the previous post we generated our tiles by enumerating filled octants.
If we take the 4 octants that make up one face, we can convert that into a 7x7 image easily.
Let&rsquo;s say if two adjacent octants are filled, we want the whole row of pixels to be filled. If we have 3 of 4 octants
the socket will look like this:</p>
<p><img src="3octs.png" alt="3 oct sock" loading="lazy" /></p>
<p>The code is relatively straightforward:</p>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-1"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gen_sock</span><span class="p">(</span><span class="n">cube_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">face_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">seen_socks</span><span class="p">:</span> <span class="n">Sockets</span><span class="p">,</span> <span class="n">bitmap_size</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Convert a 2x2 face into a bitmap, then encode it as a socket.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cube</span> <span class="o">=</span> <span class="n">int_to_cube</span><span class="p">(</span><span class="n">cube_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">face</span> <span class="o">=</span> <span class="n">get_face</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">face_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Generate a bitmap that has some room in the middle.</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># It&#39;s 7x7, so we can have more complex tiles with complex sockets elsewhere.</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">bitmap_size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># must be odd for 1 pixel gutter in center</span>
</span></span><span class="line"><span class="cl">    <span class="n">fill_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bitmap_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">socket_bitmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="p">[</span><span class="n">x</span><span class="p">])):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">face</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="n">sx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">bitmap_size</span> <span class="o">-</span> <span class="n">fill_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">sy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">bitmap_size</span> <span class="o">-</span> <span class="n">fill_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">ex</span> <span class="o">=</span> <span class="n">sx</span> <span class="o">+</span> <span class="n">fill_size</span>
</span></span><span class="line"><span class="cl">            <span class="n">ey</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">fill_size</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">face</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">ex</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">face</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">ey</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">socket_bitmap</span><span class="p">[</span><span class="n">sx</span><span class="p">:</span><span class="n">ex</span><span class="p">,</span> <span class="n">sy</span><span class="p">:</span><span class="n">ey</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Set the very center bit when the whole thing is filled</span>
</span></span><span class="line"><span class="cl">    <span class="n">socket_bitmap</span><span class="p">[</span><span class="n">fill_size</span><span class="p">,</span> <span class="n">fill_size</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">face</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Deduplicate sockets that are just transforms of other sockets</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">seen_socks</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&#34;seen socks util is required&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">face_name</span> <span class="ow">in</span> <span class="n">v_face_names</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">seen_socks</span><span class="o">.</span><span class="n">store_v</span><span class="p">(</span><span class="n">socket_bitmap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">seen_socks</span><span class="o">.</span><span class="n">store_h</span><span class="p">(</span><span class="n">socket_bitmap</span><span class="p">)</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-1">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<h1>Flexibility in geometry</h1><p><img src="sockpaint.png" alt="socket painting" loading="lazy" /></p>
<p>We don&rsquo;t have to worry about floating point errors or perfectly aligning geometry.
If we want to cover seams with some rocks or a mesh skirt, we are free to do so.</p>
<h1>Building Adjacency Map</h1><p>So far we&rsquo;ve looked at optimizing the asset creation workflow, and dug into some
details on how we get that into the game. What will we do with that data in game?</p>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-2"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Adjacency</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Index first by face, then by prototype id. </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># The value is a bitmask.</span>
</span></span><span class="line"><span class="cl">    <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="n">prototypes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Prototype</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prototypes</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prototypes</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">prototypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">compatible</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">prototypes</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">                        <span class="n">matrix</span><span class="p">[</span><span class="n">face</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span>  <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">matrix</span><span class="p">[</span><span class="n">opposite</span><span class="p">(</span><span class="n">face</span><span class="p">),</span> <span class="n">to</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span>  <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> </span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-2">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<p>Here we build a list of 6 arrays of N bitmasks, where the bitmask has length N.</p>
<p>If we look at this nice <a href="https://bolddunkley.itch.io/wfc-mixed" target="_blank" rel="noopener">WFC web demo</a>, we
can think of each cell in our grid as containing the entire tilset to start. The tiles
available to choose in each cell can be called its domain.</p>
<p>Once a cell &ldquo;picks&rdquo; a tile, we set its domain to a single item. Neightbors domains
are reduced to only contain tiles compatible with something in it&rsquo;s neighbors domain.</p>
<p>Our adjacency could be modeled as a list of 6 faces where each element in the list
maps a socket to the set of prototypes that are compatible with it.</p>
<p>A naive way to propagte things out would be something like this using a ton of unions:</p>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-3"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">allowed</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">possibility</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">allowed</span> <span class="o">=</span> <span class="n">allowed</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">adjacency</span><span class="p">[</span><span class="n">face</span><span class="p">][</span><span class="n">possibility</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">allowed</span><span class="p">)</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-3">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<p>Instead we could have those sets be a <code>BigBitmask</code>. Essentially a list of integers. 4 64 bit integers would be 256 possible tiles.
Each bit index represents a tile ID. Replace the union with a bitwise OR and things speed up quite a bit.</p>
<p>The caveat is iterating over the &ldquo;set bits&rdquo; could be slow, but most <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005fclzll" target="_blank" rel="noopener">CPUs support an instruction</a>
for finding the &ldquo;next set bit&rdquo;.</p>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-4"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">allowed</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">possibility</span> <span class="ow">in</span> <span class="n">set_bit_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">allowed</span> <span class="o">|=</span> <span class="n">adjacency</span><span class="p">[</span><span class="n">face</span><span class="p">][</span><span class="n">possibility</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">domain</span> <span class="o">&amp;=</span> <span class="n">allowd</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-4">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>Wave Function Collapse: Enumerating tiles</title>
      <link>https://landow.dev/posts/wfc/wfc-02-tiles/</link>
      <pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://landow.dev/posts/wfc/wfc-02-tiles/</guid>
      <description>Oskar St책lberg&amp;rsquo;s and BorisTheBrave&amp;rsquo;s willingness to share the dirty details of their hard work is invaluable.
Brute Forcing it by handIn the last blog, I showed a tileset created entirely by hand. Some very important tiles were missing. These diagnonal pieces:
When I realized I needed these, I added more test cases and things still broke. I later realized, that I also needed these combinations of corners and edges:
There must be an algorighmic way.</description>
      <content:encoded><![CDATA[<p>Oskar St책lberg&rsquo;s and BorisTheBrave&rsquo;s willingness to share the dirty
details of their hard work is invaluable.</p>
<hr>
<h1>Brute Forcing it by hand</h1><p>In the last blog, I showed a tileset created entirely by hand.
Some very important tiles were missing. These diagnonal pieces:</p>
<p><img src="diags.png" alt="Diagnoal tiles" loading="lazy" /></p>
<p>When I realized I needed these, I added more test cases and things still broke.
I later realized, that I also needed these combinations of corners and edges:</p>
<p><img src="diag-edge.png" alt="Diagnoal tiles" loading="lazy" /></p>
<p>There <em>must</em> be an algorighmic way.</p>
<h1>Oskar already figured it out</h1><p>It turns out before Townscaper he made a smaller version called
<a href="https://oskarstalberg.com/game/house/index.html" target="_blank" rel="noopener">Brick Block</a>.
In an <a href="https://tmblr.co/ZRaqvp1x7yvmD" target="_blank" rel="noopener">article in Vertex magazine</a> he explains
a way to cut a cube into 8 octants. It turns out that if you look at all the
possibilities of having an octant filled or not is 2 to the power of 8 (256).</p>
<p><img src="cubes.png" alt="cubes as 8bit ints" loading="lazy" /></p>
<p>Looking at this like an 8 bit integer means we have &ldquo;cube IDs&rdquo; from 0 to 255.
If you have all these tiles, you will <em>never</em> have an unsolvable grid of voxel data.</p>
<h1>256 tiles is a lot</h1><p>In the article, Oskar points out that a lot of these end up being rotations
or flipped versions of other permutations. He reduced that to 67 unique cases.
I ended up with 53.. I&rsquo;m still curious how we got different results.</p>
<p>I&rsquo;m not much of an artist. 53 was still too many for me!</p>
<p>In my initial attempt, I got pretty far by manually enumerating all the
possibilities needed for an infinite grid. Surely I could manually come up with
everything needed for a 2x2x2 grid.</p>
<p>I was able to go back to this classic image:</p>
<p><img src="dual-grid.jpeg" alt="oskar&rsquo;s beautiful dual tiles diagram" loading="lazy" /></p>
<p>To give these names:</p>
<ul>
<li>Empty</li>
<li>Corner</li>
<li>Edge</li>
<li>Diagonal</li>
<li>Bend</li>
<li>Full</li>
</ul>
<p>If we only model the dual grid of <em>those</em> we can eliminate the need to make
a &ldquo;diagonal&rdquo;. And we don&rsquo;t have to model an &ldquo;empty&rdquo; tile. So I started with these 4 tiles:</p>
<p><img src="basic-4.png" alt="basic 4 tiles" loading="lazy" /></p>
<p>To expand this to 3D, we transitions that let us go upwards. We can simply rotate these 4 tiles and voila.
We&rsquo;re at 8 tiles.</p>
<p>It doesn&rsquo;t fully cover it though. We have to be able to transition vertically between flat
tiles or edge tiles. We&rsquo;ll call these &ldquo;lip&rdquo; tiles since they&rsquo;re kind of skinny. There are 5.
4 for to match up to the base cases and a 5th that is a corner between two lips. It&rsquo;s basically
the &ldquo;outward&rdquo; part of an &ldquo;outward blob cut&rdquo; approach.</p>
<p><img src="lip_tiles.png" alt="lip tiles" loading="lazy" /></p>
<p>Finally, we duplicate all of these and flip them upside down so we have some dedicated for the
top layer of our 2x2x2 grid.</p>
<p>In total There are 26 tiles. Very manageable!</p>
<p><img src="alltiles.png" alt="tileset" loading="lazy" /></p>
<h1>Turning them into dual tiles</h1><p>Now to combine these tiles.</p>
<p>We can write an autotiler based on the which octants are filled.
To store the classification data we use a special naming scheme that includes:</p>
<ul>
<li>Their base type - Lip, Corner, Bend, Edge</li>
<li>Their Layer - Top, Bottom</li>
<li>Their Direction - Horizontal, Vertical, Horizontal + Vertical, Corner</li>
</ul>
<blockquote>
<p>Note: The following code was written during a long layover after an 18 hour flight. At some point I&rsquo;ll
go back and clean it up. In the meantime, I hope the comments are accurate.</p>
</blockquote>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-0"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">base_tile_for</span><span class="p">(</span><span class="n">octant</span><span class="p">,</span> <span class="n">cube_id</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">cube_arr</span> <span class="o">=</span> <span class="n">int_to_cube</span><span class="p">(</span><span class="n">cube_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;Bottom&#34;</span><span class="p">,</span> <span class="s2">&#34;Top&#34;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">octant</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># west, east, south, north, bottom, top</span>
</span></span><span class="line"><span class="cl">    <span class="n">adjacency</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># check directly adjacent (this axis changes)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">delta_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">delta_vec</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
</span></span><span class="line"><span class="cl">            <span class="n">cc</span> <span class="o">=</span> <span class="n">octant</span> <span class="o">+</span> <span class="n">delta_vec</span>
</span></span><span class="line"><span class="cl">            <span class="n">adjacency</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cube_cell_filled</span><span class="p">(</span><span class="n">cube_arr</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">adj_axes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">]</span> <span class="k">if</span> <span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># if there was any vertical adjacency, use .V suffix</span>
</span></span><span class="line"><span class="cl">    <span class="n">z_adj</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">adjacency</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># check how many cells are filled in this octant&#39;s plane for each axis</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_in_axis</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="n">cube_arr</span><span class="p">[</span><span class="n">octant</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="n">cube_arr</span><span class="p">[:,</span> <span class="n">octant</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="n">cube_arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">octant</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># if all 4 cells in some plane were filled, there was a &#34;wall&#34; in that axis</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># walls result in needing a &#34;lip&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">walls</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">==</span> <span class="mi">4</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_in_axes</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">walls</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">hw</span><span class="p">,</span> <span class="n">vw</span> <span class="o">=</span> <span class="n">walls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">walls</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">walls</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">hw</span> <span class="ow">and</span> <span class="n">vw</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Lip&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">adj_axes</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">suffix</span> <span class="o">+=</span> <span class="s2">&#34;.C&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">walls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">walls</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Lip.V&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">adj_axes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Flat&#34;</span> <span class="k">if</span> <span class="n">vw</span> <span class="k">else</span> <span class="s2">&#34;Wall&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Lip.Bend&#34;</span> <span class="k">if</span> <span class="n">vw</span> <span class="k">else</span> <span class="s2">&#34;Lip.Bend.V&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">adj_axes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Corner&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">adj_axes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Edge&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">+=</span> <span class="s2">&#34;.V&#34;</span> <span class="k">if</span> <span class="n">z_adj</span> <span class="k">else</span> <span class="s2">&#34;.H&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">adj_axes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Bend&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">+=</span> <span class="s2">&#34;.V&#34;</span> <span class="k">if</span> <span class="n">z_adj</span> <span class="k">else</span> <span class="s2">&#34;.H&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">adj_axes</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&#34;Bend.HV&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&#34;Somehow adjacency count isn&#39;t covered..??&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&#34;.&#34;</span> <span class="o">+</span> <span class="n">suffix</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-0">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<h1>Orienting the tiles</h1><p>Simply selecting the correct tile type is not enough. We must rotate the tiles so that they line up
properly. While there are <em>probably</em> some rules we could add to the mostrosity above, we don&rsquo;t need to.
Doing so would not only add complexity to the code, but require some manual setup in Blender.</p>
<p>Instead we can cheese it with Wave Function Collapse! Using a tileset with very simple geometry, we can
generate all the sockets for these &ldquo;base&rdquo; tiles. These only ever need to be generated once, and we can
store them in some JSON file to avoid needing our geometry to be perfect in the future.</p>
<p>Once we have this &ldquo;golden&rdquo; adjacency information file, we can use WFC to align everything correctly.</p>
<h1>Result</h1><p><img src="generated.png" alt="final tiles" loading="lazy" /></p>
<p>At this point, we can make the geometry as complex as we want. But if the geometry is complex,
how can we get nice sockets for the <em>actual</em> WFC using these generated tiles? The next post
will explain a better system for adjacency that doesn&rsquo;t rely on analzying 3D meshes.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Wave Function Collapse: First attempt</title>
      <link>https://landow.dev/posts/wfc/wfc-01-intro/</link>
      <pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://landow.dev/posts/wfc/wfc-01-intro/</guid>
      <description>At some point in time I followed some indie devs on Twitter. I&amp;rsquo;d occasionally see retweets of a cute building game from Oskar St책lberg. Didn&amp;rsquo;t think too much of it at the time. Later I stumbled on Martin Donald&amp;rsquo;s Wave Function Collapse video. The idea was explained so well that I had to try it out.
Creating a tilesetIn the talk Beyond Townscapers, and on twitter Oskar explains the concept of the dual-grid.</description>
      <content:encoded><![CDATA[<p>At some point in time I followed some indie devs on Twitter. I&rsquo;d occasionally see retweets of
a cute building game from <a href="https://twitter.com/OskSta" target="_blank" rel="noopener">Oskar St책lberg</a>. Didn&rsquo;t think too much of
it at the time. Later I stumbled on <a href="https://www.youtube.com/watch?v=2SuvO4Gi7uY" target="_blank" rel="noopener">Martin Donald&rsquo;s Wave Function Collapse video</a>.
The idea was explained so well that I had to try it out.</p>
<h1>Creating a tileset</h1><p>In the talk <a href="https://www.youtube.com/watch?v=Uxeo9c-PX-w&amp;t=126s" target="_blank" rel="noopener">Beyond Townscapers</a>,
and on <a href="https://twitter.com/OskSta/status/1448248658865049605" target="_blank" rel="noopener">twitter</a> Oskar explains
the concept of the dual-grid. Essentially: cut your tiles in the middle. This is my
first time making a tileset of any kind, and I don&rsquo;t know why anyone would do it
any other way.</p>
<p><img src="dual-grid.jpeg" alt="Oskar&rsquo;s Dual Grid graphic" loading="lazy" /></p>
<p>I manually modeled out what I thought were the required set of tiles in blender.
I used this graphic to guide me, and thought moving to 3 dimensions wouldn&rsquo;t be that bad.
I would just need to make each of those 2D tiles 3 times: once each for the top, middle and bottom
layers if you&rsquo;re slicing vertically.</p>
<p><img src="old-tileset.png" alt="Handmade tilset" loading="lazy" /></p>
<h1>Determining adjacency</h1><div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-0"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">face_verts</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># round to 3 decimals so equality will (sometimes) work</span>
</span></span><span class="line"><span class="cl">    <span class="n">vert_coord_3d</span> <span class="o">=</span> <span class="n">rounded_coordinate</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># compare the dimension for this face&#39;s axis</span>
</span></span><span class="line"><span class="cl">    <span class="n">location</span> <span class="o">=</span> <span class="n">vert_coord_3d</span><span class="p">[</span><span class="n">face</span><span class="o">.</span><span class="n">component</span><span class="p">]</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># using float equality is a terrible idea...</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">vert_location_1d</span> <span class="o">==</span> <span class="n">face_location_1d</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">        <span class="n">face_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vert</span><span class="o">.</span><span class="n">co</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">socket_id</span> <span class="o">=</span> <span class="n">socket_hash</span><span class="p">(</span><span class="n">face_verts</span><span class="p">)</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-0">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<p>Given a set of tiles, I could go through and look for all the vertices that sat on the bounding box faces
and generate &ldquo;sockets&rdquo;. This would be my primary piece of adjacency data. If the sockets lined up, it was
valid to place one tile adjacent to another.</p>
<p><img src="wire-sockets.png" alt="Mesh Sockets" loading="lazy" /></p>
<h1>Implementing WFC</h1><p>With a tileset, and basic adjacency information it wasn&rsquo;t too hard to whip up a basic WFC generator.
For a detailed tutorial, see <a href="https://www.youtube.com/watch?v=2SuvO4Gi7uY" target="_blank" rel="noopener">Martin Donald&rsquo;s video</a>.
The basic structure looks like this:</p>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-1"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">solve</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">work_list</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">solved</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="ow">not</span> <span class="n">solved</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">MAX_ITERATIONS</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">collapsed</span> <span class="o">=</span> <span class="n">collapse</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">collapsed</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">work_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">solved</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">work_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">cell</span> <span class="o">=</span> <span class="n">work_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">work_list</span> <span class="o">+=</span> <span class="n">propagate</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">collapse</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">unsolved</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">possibilities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unsolved</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Every cell is solved (or impossible...)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Find the unsolved cell with the fewest number of remaining possible tiles.</span>
</span></span><span class="line"><span class="cl">    <span class="n">cell</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unsolved</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">possibilities</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Reduce it to one possibility</span>
</span></span><span class="line"><span class="cl">    <span class="n">cell</span><span class="o">.</span><span class="n">possibilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">possibilities</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># reduce the possibilities of neighboring cells</span>
</span></span><span class="line"><span class="cl"><span class="c1"># to only include tiles that have adjacency sockets that line up.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># return the set of cells that were affected so we can recursively</span>
</span></span><span class="line"><span class="cl"><span class="c1"># propagate the constraint</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">propagate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Cell</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-1">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<p>Using this in a Blender python script, I could generate a random set of tiles that &ldquo;fit&rdquo; together in some space:</p>
<p><img src="random-wfc.png" alt="Random WFC result" loading="lazy" /></p>
<h1>Making it interactive</h1><p>Next, I added a preprocessing step to force empty tiles everywhere but specified coordinates.
This is essentially voxel data.
<a href="https://www.boristhebrave.com/2021/06/06/driven-wavefunctioncollapse/" target="_blank" rel="noopener">BorisTheBrave</a> calls this &ldquo;Driven&rdquo; WFC.</p>
<div class="code-block relative mt-6 first:mt-0 group/code"><div id="code-block-2"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span></span></span></code></pre></div></div><div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
    <button class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50" title="Copy code" data-clipboard-target="#code-block-2">
      <svg class="group-[.copied]/copybtn:hidden pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
      <svg class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
    </button>
  </div>
</div>
<p>Now I can build something blocky like in Minecraft. By typing coordinates by hand in python! Great&hellip;</p>
<p><img src="shape-wfc-normals.png" alt="Basically townscaper" loading="lazy" /></p>
<h1>There are some major issues</h1><p>Someone more seasoned in procedural generation, or 3D graphics in general may have noticed
a few issues. I&rsquo;ll highlight the major 3 that will each get a dedicated follow up.</p>
<p><strong>1. Some tiles have flipped normals</strong></p>
<p>Notice the red tiles on the corners of the last image?</p>
<p>The main issue is that the sockets don&rsquo;t contain any information about
which side is on the &ldquo;inside&rdquo; or outside. There are a few ways to go about tackling this.</p>
<p><strong>2. Sockets rely float equality and perfect meshes</strong></p>
<p>While we <em>want</em> two adjacent tiles to fit perfectly, sometimes they don&rsquo;t need to.
Mesh skirts and clever artwork can be used to cover up seams. If we rely on 3 decimal places
of accuracy on every vertex, we will have a hard time creating new tiles and pull our hair out
when tiles that should fit together have different sockets.</p>
<p><strong>3. The tileset is incomplete</strong></p>
<p>At this phase in the project, I would create some tiles, then create somee voxel data
and see if the generator would fail. When the generator failed, I&rsquo;d stare for a while until I realized
I missed some 3D version of Oskar&rsquo;s dual grid guide. In the screenshots above, we&rsquo;re missing <em>every</em>
variation of the &ldquo;diagonal&rdquo; tile.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>